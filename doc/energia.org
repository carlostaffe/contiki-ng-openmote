* Software-based On-line Energy Estimation for SensorNodes
Paper original que describe el funcionamiento en =contiki-os=. Es posible que la implementación en =contiki-ng= sea diferente.

** Funcionamiento
Cuando un componente (radio, sensor, led) es encendido, energest almacena un /timestamp/(=rtimer ticks=). En el instante en el que se apaga el componente, se produce un nuevo /timestamp/ y se calcula un delta y agregado a un total que indica cuanto tiempo ha permanecido encendido dicho módulo. 
Energest mantiene una tabla con una lista de los componentes y el tiempo durante el cual han permanecido encendidos.

El consumo de un módulo es estimado ante un cambio de estado, en el caso de la CPU cuando pasa de modo normal a modo de ahorro de energía.

El registro de tiempo se realiza mediante /on chip timers/ los cuales (al menos para =MSP430=) permanecen activos durante el modo de bajo consumo.

** Consideraciones especiales
+ Battery Lifetime Estimation :: No es posible traducir el consumo promedio en tiempo de vida de un mote alimentado por batería pues las baterías no son lineales.
+ Elementos no lineales :: Ciertos componentes del HW son no lineales, de tal manera que el consumo no se puede calcular como la suma de los consumos individuales de cada componente.

* Energest rontiki-ng
https://github.com/contiki-ng/contiki-ng/wiki/Documentation:-Energest
** Tipos 
Existen al menos cinco tipos predefinidos que reconocen todas las plataformas. 
| ENERGEST_TYPE_CPU      | Tiempo de actividad de la CPU |
| ENERGEST_TYPE_LPM      | Tiempo de Low Power Mode      |
| ENERGEST_TYPE_DEEP_LPM | Tiempo de Deep Low Power Mode |
| ENERGEST_TYPE_TRANSMIT | Tiempo de transmisión         |
| ENERGEST_TYPE_LISTEN   | Tiempo de recepción           |

Para leer cualquiera de estos, se puede utilizar la función =energest_type_time(<tipo>)=. Ej:

#+begin_src c
  energest_flush();
  unsigned long last_time = ENERGEST_GET_TOTAL_TIME();
  unsigned long last_cpu = energest_type_time(ENERGEST_TYPE_CPU);
  unsigned long last_lpm = energest_type_time(ENERGEST_TYPE_LPM);
  unsigned long curr_tx = energest_type_time(ENERGEST_TYPE_TRANSMIT);
  unsigned long last_deep_lpm = energest_type_time(ENERGEST_TYPE_DEEP_LPM);
  unsigned long last_rx = energest_type_time(ENERGEST_TYPE_LISTEN);
#+end_src

No en todos los CPU funcionan en LPM y en Deep LPM. 

Para el CC2538 (openmote) se lee lo siguiente en el datasheet:
| Active-Mode RX (CPUIdle)                                                         | 20 mA  |
| Active-Mode TX at 0 dBm(CPUIdle)                                                 | 24 mA  |
| PowerMode1 (4-μs Wake-Up,32-KBRAMRetention,Full RegisterRetention)               | 0.6 mA |
| PowerMode2 (SleepTimerRunning,16-KBRAMRetention,ConfigurationRegisterRetention)  | 1.3 uA |
| PowerMode3 (ExternalInterrupts,16-KBRAMRetention,ConfigurationRegisterRetention) | 0.4 uA |

FIXME: que estos modos existan, no significa que se encuentren implementados en contiki-ng.

FIXME: Es posible también que una plataforma defina nuevos tipos para energest, por ejemplo para el sensor de temperatura,led, etc.
** Definir tipos nuevos
Debe ser posible (no probado) hacer un perfilaje energético de una función en una aplicación.
Esto puede ser útil para, por ejemplo, calcular qué tanta energía utiliza el CPU en realizar una tarea (enviar un mensaje o una serie de mensajes).

* Low Power Mode - LPM

** Intro

Contiki define tres tipos de modos de ahorro de energía. Estos son ordenados del modo de menor al mayor ahorro: PM0, PM1 y PM2

** Heurística para poner o no al CPU en /low power mode/

Cuando el planificador determina que todos los eventos han sido atendidos, llama a =lpm_enter(void)=, la cual decide en qué modo LPM 0, 1 o 2 pone al procesador.

El modo de ahorro es elegido en función de los siguientes criterios:
+ Esta apagado el RF?
+ Los periféricos registrados permiten PM1+?
+ Se disparará una interrupción de sleep timer?
 
Si la respuesta a cualquiera es no, el CPU pasa a PM0 y se despertará ante cualquier interrupción.

Caso contrario pasa a PM1 o PM2 según la duración prevista del sueño.

** PM1+
En modo PM1 o PM2 la CPU cambiar la frecuencia de trabajo a 16MHz. Además cómo no tiene timers, el proceso es ininterrumpible y tiene una duración predeterminada.

Notar que mientras en PM0 la radio puede estar encendida, en PM1+ esto no es posible.

** lpm.c - Comentado

En este apartado, intento explicar el funcionamiento del modo de ahorro de energía. Según se ve en el archivo fuente =arch/cpu/cc2538/lpm.c=

 En primer lugar se revisa el flag =LPM_CONF_ENABLE=:
#+begin_src c
#if LPM_CONF_ENABLE != 0
#+end_src
 Luego se definen intervalos de duración de los modos PM1+, en términos de ticks de rtimer. Según el comentario del código, un tick dura alrededor de 30.5 usec.
La lógica es que si la duración del período libre de interrupciones es menor a los thresholds a continuación definidos, no entrar en PM+1. Recordar que existe un período de transición entre los modos, por lo cual, no tiene sentido caer a PM1+ si se debe despertar poco tiempo después.
 #+begin_src c
/*---------------------------------------------------------------------------*/
/*
 * Deep Sleep thresholds in rtimer ticks (~30.5 usec)
 *
 * If Deep Sleep duration < DEEP_SLEEP_PM1_THRESHOLD, simply enter PM0
 * If duration < DEEP_SLEEP_PM2_THRESHOLD drop to PM1
 * else PM2.
 */
#define DEEP_SLEEP_PM1_THRESHOLD    10
#define DEEP_SLEEP_PM2_THRESHOLD    100
 #+end_src
 FIXME: No estoy seguro lo que hace esto. 
 #+begin_src c
 /*---------------------------------------------------------------------------*/
#define assert_wfi() do { __asm("wfi"::); } while(0)
/*---------------------------------------------------------------------------*/
 #+end_src
 
 El siguiente bloque declara 3 estructuras rtimer en las cuales se guardan estadísticas que indican cuanto tiempo pasó el cpu en cada modo de ahorro de energía.
 Además define macros para iniciar y actualizar las estructuras.
#+begin_src c
  #if LPM_CONF_STATS
  rtimer_clock_t lpm_stats[3];

  #define LPM_STATS_INIT()                                                       \
    do {                                                                         \
      memset(lpm_stats, 0, sizeof(lpm_stats));                                   \
    } while (0)
  #define LPM_STATS_ADD(pm, val)                                                 \
    do {                                                                         \
      lpm_stats[pm] += val;                                                      \
    } while (0)
  #else
  #define LPM_STATS_INIT()
  #define LPM_STATS_ADD(stat, val)
  #endif
#+end_src
 En la siguiente variable se guarda el máximo PM permitido.
#+begin_src c
/*---------------------------------------------------------------------------*/
/* Stores the currently specified MAX allowed PM */
static uint8_t max_pm;
/*---------------------------------------------------------------------------*/
#+end_src

Define un entero, que será utilizado para inicializar punteros a funciones. Las cuales a su vez serán utilizadas para chequear si un periférico permite PM1. Si no se ha definido un valor, defaultea a 5.
#+begin_src c
/*---------------------------------------------------------------------------*/
/* Buffer to store peripheral PM1+ permission FPs */
#ifdef LPM_CONF_PERIPH_PERMIT_PM1_FUNCS_MAX
#define LPM_PERIPH_PERMIT_PM1_FUNCS_MAX LPM_CONF_PERIPH_PERMIT_PM1_FUNCS_MAX
#else
#define LPM_PERIPH_PERMIT_PM1_FUNCS_MAX 5
#endif
#+end_src

Define N variables que son punteros a funciones =periph_permit_pm1_funcs= que regresan bool y toman void como parametro, con N igual a un número que creo que es la cantidad de funciones de atención a periféricos.
NO estoy seguro.
Las funciones registradas son llamadas por el módulo LPM para pedir permiso para pasar a PM1+.
#+begin_src c
  static lpm_periph_permit_pm1_func_t
  periph_permit_pm1_funcs[LPM_PERIPH_PERMIT_PM1_FUNCS_MAX];
 /*---------------------------------------------------------------------------*/
 /* When changing power modes, the LPM driver will call all FPs registered with
 * this function. The peripheral's function will return true or false to permit
 *  prohibit PM1+ respectively. If at least one peripheral returns false, the
 * SoC will drop to PM0 Deep Sleep instead.
 */
  static bool
  periph_permit_pm1(void)
  {
    int i;

    for(i = 0; i < LPM_PERIPH_PERMIT_PM1_FUNCS_MAX &&
        periph_permit_pm1_funcs[i] != NULL; i++) {
      if(!periph_permit_pm1_funcs[i]()) {
        return false;
      }
    }
    return true;
  }

#+end_src
